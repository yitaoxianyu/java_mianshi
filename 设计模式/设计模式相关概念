单例模式 :
什么是单例模式 : 一个类只能有一个实例,会自行进行实例化(构造方法私有化)
单例模式的两种模式 : 饿汉式和懒汉式
饿汉式 : 指的是在加载类的过程中就会自动实例化
懒汉式 : 调用相关方法时,才会进行实例化(实现懒汉式的方法采用双重检查锁保证了性能)

代理模式:
定义 : 即想调用一个对象方法时,调用对应的代理对象
好处 : 可以实现解耦,可以对对应的方法进行功能上的增强
两种模式 : 静态代理和动态代理
    静态代理 :
        写一个代理类实现同样的接口,并且具有一个成员变量用来存储需要被代理的对象,实现代理对象的方法进行功能增强
    动态代理 :
        需要有一个类来实现对应InvocationHandler接口中的invoke方法,并且调用Proxy的getInstance方法传入实现接口的对象即可
jdk实现动态代理的缺点 : jdk动态代理只能将代理对象由接口实现的方法进行代理

简单工厂模式(属于创造形模式的一种,又称静态方法工厂模式) :
定义 : 有一个工厂类用来专门创建实例,而不由程序员自己进行创建,静态方法中进行实例对象
好处 : 使得对象创建和使用分离
缺点 : 当想要修改类的内容是相对麻烦,并且工厂中的产品都需要继承同一个类

工厂模式 :
定义 : 定义一个用于创建对象的接口(工厂抽象类),让子类决定实现哪个类,工厂方法使一个类的实例化延迟到其子类(让具体工厂类来生产具体的产品)
好处 : 通过继承通用的工厂接口,不同的工厂类实现不同实例对象的方法这样使得类的创建可以更加多样
缺点 : 一个工厂只能生产一个大类的产品,由此就衍生出了抽象工厂的设计模式即让一个工厂可以生产出不同大类的产品

抽象工厂模式 :
如何实现 : 即让工厂实现工厂接口(接口中写用于生产多个大类的工厂方法),将产品生产的周期推迟到具体实现类中的对应工厂方法中
好处 : 可以实现一个工厂类生产多种产品,不需要额外创建对应产品的工厂
缺点 : 对于程序设计而言影响了开闭原则(尽量拓展而不进行修改)

装饰器模式 :
如何实现 : 设想一个场景,一个厂家推出一种机器人功能有唱歌,如果他想让机器人还想跳舞的话,他就需要推出第二代机器人(即继承一代拓展功能),
但是有人对机器人实行了改造,在原有机器人上实现了跳舞功能这就是装饰器模式的主要思想(即进行功能拓展,即实现和需要被装饰的接口保存实例)
好处 : 不用使用子类和父类的继承,而是使用实现统一接口进行功能拓展降低了耦合度
与代理模式的区别 : 装饰器模式是在原有的基础上进行功能拓展,而代理模式是实现原有的功能基础上进行增强

